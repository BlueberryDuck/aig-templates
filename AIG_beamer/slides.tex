\section{Introduction}

\begin{frame}{Handling Inconsistent Information}
    \begin{block}{Classical vs. Paraconsistent Logic}
        \begin{itemize}
            \item \darkhighlight{Classical logic} deems any inconsistency as catastrophic.
            \item \darkhighlight{Paraconsistent logic} allows reasoning with inconsistent knowledge bases.
        \end{itemize}
    \end{block}
    \begin{itemize}
        \item Inconsistency measures quantify the extent of inconsistencies in knowledge bases.
        \item Focus: Extending these measures to non-monotonic frameworks like ASP.
    \end{itemize}
\end{frame}

\begin{frame}{Inconsistency Measures}
    \begin{block}{Definition}
        An \darkhighlight{inconsistency measure} is a function $\mathcal{I}(\mathcal{K})$ that increases with the number of inconsistencies in a knowledge base $\mathcal{K}$. $\mathcal{I}(\mathcal{K}) = 0$ if $\mathcal{K}$ is consistent.
    \end{block}
    \begin{itemize}
        \item A popular approach is counting minimal inconsistent subsets: $\mathcal{I}_{\text{MI}}(\mathcal{K}) = \left| I_{\min}(\mathcal{K}) \right|$.
        \item Minimal inconsistent subsets represent atomic conflicts.
        \item [Example here]
    \end{itemize}
\end{frame}

\begin{frame}{Non-monotonic logics}
    \begin{block}{Definition}
        non-monotonic
    \end{block}
\end{frame}

\section{Answer Set Programming}

\begin{frame}{Answer Set Programming (ASP)}
    \begin{block}{Logic Programming}
        \begin{itemize}
            \item ASP is a form of declarative programming for complex combinatorial problems.
            \item Logic programs contain disjunctions in the head and two kinds of negation:
                  \begin{itemize}
                      \item Strong negation ($\neg$)
                      \item Default negation (\texttt{not})
                  \end{itemize}
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Answer Set Programming (ASP)}
    \begin{alertblock}{Rule Structure}
        A logic program $P$ consists of rules of the form:
        \[
            \yellowmathhighlight{l_0 \lor \dots \lor l_k} \leftarrow \darkmathhighlight{l_{k+1}, \dots, l_m}, \mathhighlight{\text{not } l_{m+1}, \dots, \text{not } l_n}
        \]
        Divided into:
        \begin{itemize}
            \item \yellowhighlight{Head}: $head(r) = \{l_0, \dots, l_k\}$
            \item \darkhighlight{Positive body}: $pos(r) = \{l_{k+1}, \dots, l_m\}$
            \item \highlight{Negative body}: $neg(r) = \{l_{m+1}, \dots, l_n\}$
        \end{itemize}
    \end{alertblock}
\end{frame}

\begin{frame}{Answer Set Programming (ASP)}
    \begin{block}{Definition}
        Let $P$ be a logic program over $A$ with $neg(r) = \emptyset$ for all $r \in P$.
        \begin{itemize}
            \item A set $M$ of literals is a \darkhighlight{model} of $P$ if:
                  \begin{itemize}
                      \item For all $r \in P$, if $pos(r) \subseteq M$, then $head(r) \cap M \neq \emptyset$.
                  \end{itemize}
            \item $M$ is an \darkhighlight{answer set} of $P$ if it is minimal among models.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Example}
    \begin{exampleblock}{Logic Program with No Answer Set}
        Consider $P = \{a \lor b.$, $a \leftarrow b.$, $c \leftarrow \text{not }b.$, $\neg c \leftarrow \text{not }b.\}$

        Candidates: $\{a\}$, $\{b\}$, $\{a, b\}$.

        \[
            \begin{array}{lcl}
                P^{\{a\}}   & : & a \lor b. \quad a \leftarrow b. \quad c. \quad \neg c. \\
                P^{\{b\}}   & : & a \lor b. \quad a \leftarrow b.                        \\
                P^{\{a,b\}} & : & a \lor b. \quad a \leftarrow b.
            \end{array}
        \]

        None are minimal models; $P$ has no answer set.
    \end{exampleblock}
\end{frame}

\section{Strong Inconsistency}

\begin{frame}{Strong Inconsistency in Non-Monotonic Logics}
    \begin{block}{Inconsistent Subsets}
        \begin{itemize}
            \item $I(\mathcal{K})$: All inconsistent subsets.
            \item $I_{\min}(\mathcal{K})$: Minimal inconsistent subsets.
            \item $C(\mathcal{K})$: Consistent subsets.
            \item $C_{\max}(\mathcal{K})$: Maximal consistent subsets.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Hitting Set Duality}
    \begin{block}{Theorem}
        In propositional logic, $\mathcal{H} \subseteq \mathcal{K}$ is a minimal hitting set of $I_{\min}(\mathcal{K})$ if and only if $\mathcal{K} \setminus \mathcal{H} \in C_{\max}(\mathcal{K})$.
    \end{block}
\end{frame}

\begin{frame}{Strongly $\mathcal{K}$-Inconsistent Subsets}
    \begin{block}{Definition}
        $\mathcal{H} \subseteq \mathcal{K}$ is \darkhighlight{strongly $\mathcal{K}$-inconsistent} if all its supersets within $\mathcal{K}$ are inconsistent.

        Denoted as $SI(\mathcal{K})$.

        Minimal strongly inconsistent subsets: $SI_{\min}(\mathcal{K})$.
    \end{block}
\end{frame}

\begin{frame}{Example}
    \begin{exampleblock}{Resolving Inconsistency with Additional Information}
        \begin{itemize}
            \item $\mathcal{K} = \{b., \neg b \leftarrow \text{not } a.\}$
            \item Adding $a.$ to $\mathcal{K}$ makes it consistent.
            \item Shows that in non-monotonic logics, adding information can resolve conflicts.
        \end{itemize}
    \end{exampleblock}
\end{frame}

\section{Measures Based on Minimal Inconsistent Subsets}

\begin{frame}{Inconsistency Measures for Non-Monotonic Logics}
    \begin{block}{Measure $\mathcal{I}_{\text{MSI}}$}
        \[
            \mathcal{I}_{\text{MSI}}(\mathcal{K}) = \left| SI_{\min}(\mathcal{K}) \right|
        \]
        Counts the number of minimal strongly inconsistent subsets.
    \end{block}
    \begin{block}{Measure $\mathcal{I}_{\text{MSI}}^\text{C}$}
        \[
            \mathcal{I}_{\text{MSI}}^\text{C}(\mathcal{K}) = \sum_{\mathcal{H} \in SI_{\min}(\mathcal{K})} \frac{1}{|\mathcal{H}|}
        \]
        Considers the size of each minimal inconsistent subset.
    \end{block}
\end{frame}

\begin{frame}{Measure $\mathcal{I}_{\text{p}}$}
    \begin{block}{Definition}
        \[
            \mathcal{I}_{\text{p}}(\mathcal{K}) = \left| \bigcup_{\mathcal{H} \in SI_{\min}(\mathcal{K})} \mathcal{H} \right|
        \]
        Counts the total number of problematic formulas.
    \end{block}
\end{frame}

\begin{frame}{Example}
    \begin{exampleblock}{Calculating Inconsistency Measures}
        For $P = \{a \leftarrow \text{not } a, b.$, $a \leftarrow \text{not } c, \text{not } d.$, $b.$, $c.$, $d.\}$:

        \begin{itemize}
            \item $SI_{\min}(P) = \{\{a \leftarrow \text{not } a, b., b., c.\}, \{a \leftarrow \text{not } a, b., b., d.\}\}$
            \item $\mathcal{I}_{\text{MSI}}(P) = 2$
            \item $\mathcal{I}_{\text{MSI}}^\text{C}(P) = \frac{2}{3}$
            \item $\mathcal{I}_{\text{p}}(P) = 4$
        \end{itemize}
    \end{exampleblock}
\end{frame}

\section{Rationality Postulates}

\begin{frame}{Rationality Postulates}
    \begin{block}{Purpose}
        \begin{itemize}
            \item Ensure inconsistency measures behave reasonably.
            \item Provide guidelines for development and evaluation.
        \end{itemize}
    \end{block}
\end{frame}

\subsection{Basic Postulates}

\begin{frame}{Basic Postulates}
    \begin{block}{Consistency}
        For any knowledge base $\mathcal{K}$:
        \[
            \mathcal{I}(\mathcal{K}) = 0 \quad \text{iff} \quad \mathcal{K} \text{ is consistent}
        \]
    \end{block}
    \begin{block}{Strong Monotonicity}
        If $\mathcal{K}'$ \darkhighlight{preserves conflicts} of $\mathcal{K}$:
        \[
            \mathcal{I}(\mathcal{K}) \leq \mathcal{I}(\mathcal{K} \cup \mathcal{K}')
        \]
    \end{block}
\end{frame}

\begin{frame}{Independence Postulate}
    \begin{block}{Neutral Formulas}
        A formula $\alpha$ is \darkhighlight{neutral} if:
        \[
            \forall \mathcal{H} \subseteq \mathcal{K}: \mathcal{H} \in C(\mathcal{K}) \Leftrightarrow \mathcal{H} \cup \{\alpha\} \in C(\mathcal{K})
        \]
    \end{block}
    \begin{block}{Independence}
        If $\alpha$ is neutral:
        \[
            \mathcal{I}(\mathcal{K}) = \mathcal{I}(\mathcal{K} \backslash \{\alpha\})
        \]
    \end{block}
\end{frame}

\subsection{Extended Postulates}

\begin{frame}{Strong Equivalence}
    \begin{block}{Definition}
        Knowledge bases $\mathcal{K}$ and $\mathcal{K}'$ are \darkhighlight{strongly equivalent} ($\mathcal{K} \equiv_S \mathcal{K}'$) if:
        \[
            \text{ACC}(\mathcal{K} \cup \mathcal{G}) = \text{ACC}(\mathcal{K}' \cup \mathcal{G}) \quad \forall \mathcal{G}
        \]
    \end{block}
    \begin{block}{Postulate}
        If $\mathcal{K} \equiv_S \mathcal{K}'$:
        \[
            \mathcal{I}(\mathcal{K}) = \mathcal{I}(\mathcal{K}')
        \]
    \end{block}
\end{frame}

\begin{frame}{Separability}
    \begin{block}{Definition}
        If $SI_{\min}(\mathcal{K} \cup \mathcal{K}') = SI_{\min}(\mathcal{K}) \cup SI_{\min}(\mathcal{K}')$ and $SI_{\min}(\mathcal{K}) \cap SI_{\min}(\mathcal{K}') = \emptyset$:
        \[
            \mathcal{I}(\mathcal{K} \cup \mathcal{K}') = \mathcal{I}(\mathcal{K}) + \mathcal{I}(\mathcal{K}')
        \]
    \end{block}
\end{frame}

\begin{frame}{Compliance of Measures}
    \begin{block}{Proposition}
        Measures $\mathcal{I}_{\text{MSI}}$, $\mathcal{I}_{\text{MSI}}^\text{C}$, and $\mathcal{I}_{\text{p}}$ satisfy:

        \begin{itemize}
            \item Consistency
            \item Strong Monotonicity
            \item Independence
            \item FW-Strong Equivalence
            \item Strong Equivalence Replacement
            \item Strong Super-Additivity
        \end{itemize}

        Additionally, $\mathcal{I}_{\text{MSI}}$ and $\mathcal{I}_{\text{MSI}}^\text{C}$ satisfy Separability.
    \end{block}
\end{frame}

\section{Summary and Conclusion}

\begin{frame}{Summary}
    \begin{itemize}
        \item Addressed measuring inconsistencies in non-monotonic knowledge bases.
        \item Introduced \highlight{strong inconsistency} for non-monotonic logics.
        \item Applied strong inconsistency to extend inconsistency measures.
        \item Discussed rationality postulates for non-monotonic logics.
    \end{itemize}
\end{frame}

\begin{frame}{Conclusion}
    \begin{itemize}
        \item Provided an overview of inconsistencies in non-monotonic logics.
        \item Future work: Improve measures and compliance with rationality postulates.
        \item Applications: Repairing knowledge bases by adding formulas.
    \end{itemize}
\end{frame}

% Thank You slide
\begin{frame}
    \begin{center}
        \Huge{Thank You!}
    \end{center}
\end{frame}
