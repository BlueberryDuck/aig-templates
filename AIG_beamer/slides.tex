\section{Introduction}

\begin{frame}{Handling Inconsistent Information}
    \begin{block}{Classical vs. Paraconsistent Logic}
        \begin{itemize}
            \item \darkhighlight{Classical logic} deems any inconsistency as catastrophic.
            \item \darkhighlight{Paraconsistent logic} allows reasoning with inconsistent knowledge bases.
        \end{itemize}
    \end{block}
    \begin{itemize}
        \item Inconsistency measures quantify the extent of inconsistencies in knowledge bases.
        \item Focus: Extending these measures to non-monotonic frameworks like ASP.
    \end{itemize}
\end{frame}

\begin{frame}{Inconsistency Measures}
    \begin{block}{Definition}
        An \darkhighlight{inconsistency measure} is a function $\mathcal{I}(\mathcal{K})$ that increases with the number of inconsistencies in a knowledge base $\mathcal{K}$. $\mathcal{I}(\mathcal{K}) = 0$ if $\mathcal{K}$ is consistent.
    \end{block}
    \begin{itemize}
        \item A popular approach is counting minimal inconsistent subsets: $\mathcal{I}_{\text{MI}}(\mathcal{K}) = \left| I_{\min}(\mathcal{K}) \right|$.
        \item Minimal inconsistent subsets represent atomic conflicts.
        \item [Example here]
    \end{itemize}
\end{frame}

\begin{frame}{Non-monotonic logics}
    \begin{block}{Definition}
        TODO
    \end{block}
\end{frame}

\section{Answer Set Programming}

\begin{frame}{Answer Set Programming (ASP)}
    \begin{block}{Logic Programming}
        \begin{itemize}
            \item ASP is a form of declarative programming for complex combinatorial problems.
            \item Logic programs contain disjunctions in the head and two kinds of negation:
                  \begin{itemize}
                      \item Strong negation ($\neg$)
                      \item Default negation (\texttt{not})
                  \end{itemize}
        \end{itemize}
    \end{block}
    TODO
\end{frame}

\begin{frame}{Answer Set Programming (ASP)}
    \begin{alertblock}{Rule Structure}
        A logic program $P$ consists of rules of the form:
        \[
            \darkmathhighlight{l_0 \lor \dots \lor l_k} \leftarrow \yellowmathhighlight{l_{k+1}, \dots, l_m}, \mathhighlight{\text{not } l_{m+1}, \dots, \text{not } l_n}
        \]
        Divided into:
        \begin{itemize}
            \item \darkhighlight{Head}: $head(r) = \{l_0, \dots, l_k\}$
            \item \yellowhighlight{Positive body}: $pos(r) = \{l_{k+1}, \dots, l_m\}$
            \item \highlight{Negative body}: $neg(r) = \{l_{m+1}, \dots, l_n\}$
        \end{itemize}
    \end{alertblock}
\end{frame}

\begin{frame}{Answer Set Programming (ASP)}
    \begin{block}{Reduct of a Logic Program}
        To extend answer sets to logic programs with negation, we define the \darkhighlight{reduct} of a program $P$ with respect to a set of literals $M$:
        \[
            P^M = \{head(r) \leftarrow pos(r) \mid r \in P, \mathhighlight{neg(r) \cap M = \emptyset}\}
        \]
    \end{block}
    \begin{block}{Answer Sets via Reduct}
        A set $M$ of literals is an \darkhighlight{answer set} of a logic program $P$ if:
        \begin{itemize}
            \item $M$ is an answer set (minimal model) of the \darkhighlight{reduct} $P^M$.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Example}
    \begin{exampleblock}{Computing Answer Sets Using the Reduct}
        Consider the logic program:
        \[
            \begin{array}{lcl}
                a      & \leftarrow & \text{not } b \\
                b      & \leftarrow & \text{not } a \\
                c      & \leftarrow & a             \\
                \neg c & \leftarrow & b
            \end{array}
        \]
        Candidates are $M_1 = \{a, c\}$ and $M_2 = \{b, \neg c\}$\\
        Reducts:
        \[
            \begin{array}{lcl}
                P^{M_1} & = & \{a.\quad c \leftarrow a.\}      \\
                P^{M_2} & = & \{b.\quad \neg c \leftarrow b.\}
            \end{array}
        \]
        Both $M_1$ and $M_2$ are minimal models of their respective reducts; thus, both are \darkhighlight{answer sets} of $P$.
    \end{exampleblock}
\end{frame}

\section{Strong Inconsistency}

\begin{frame}{Strong Inconsistency in Non-Monotonic Logics}
    \begin{block}{Key Concept}
        Subsets of a knowledge base that remain insonsistent, even when additional information is added.
    \end{block}

    \begin{block}{Strongly $\mathcal{K}$-Inconsistent Subsets}
        $\mathcal{H} \subseteq \mathcal{K}$ is \darkhighlight{strongly $\mathcal{K}$-inconsistent} if all its supersets within $\mathcal{K}$ are inconsistent.

        Denoted as $SI(\mathcal{K})$.

        Minimal strongly $\mathcal{K}$-inconsistent subsets: $SI_{\min}(\mathcal{K})$.
    \end{block}

    \begin{exampleblock}{Resolving Inconsistency with Additional Information}
        $\mathcal{K} = \{b., \neg b \leftarrow \text{not } a.\}$

        Adding $a.$ to $\mathcal{K}$ makes it consistent.

        This shows that in non-monotonic logics, adding information can resolve conflicts.
    \end{exampleblock}
\end{frame}

\section{Measures Based on Minimal Inconsistent Subsets}

\begin{frame}{Inconsistency Measures for Non-Monotonic Logics}
    \begin{block}{Measure $\mathcal{I}_{\text{MSI}}$}
        \[
            \mathcal{I}_{\text{MSI}}(\mathcal{K}) = \left| SI_{\min}(\mathcal{K}) \right|
        \]
        Counts the number of minimal strongly inconsistent subsets.
    \end{block}
    \begin{block}{Measure $\mathcal{I}_{\text{MSI}}^\text{C}$}
        \[
            \mathcal{I}_{\text{MSI}}^\text{C}(\mathcal{K}) = \sum_{\mathcal{H} \in SI_{\min}(\mathcal{K})} \frac{1}{|\mathcal{H}|}
        \]
        Considers the size of each minimal inconsistent subset.
    \end{block}
\end{frame}

\begin{frame}{Inconsistency Measures for Non-Monotonic Logics}
    \begin{block}{Measure $\mathcal{I}_{\text{p}}$}
        \[
            \mathcal{I}_{\text{p}}(\mathcal{K}) = \left| \bigcup_{\mathcal{H} \in SI_{\min}(\mathcal{K})} \mathcal{H} \right|
        \]
        Counts the total number of problematic formulas.
    \end{block}
\end{frame}

\begin{frame}{Inconsistency Measures for Non-Monotonic Logics}
    \begin{exampleblock}{Calculating Inconsistency Measures}
        For $P = \{a \leftarrow \text{not } a, b.$, $a \leftarrow \text{not } c, \text{not } d.$, $b.$, $c.$, $d.\}$:

        \begin{itemize}
            \item $SI_{\min}(P) = \{\{a \leftarrow \text{not } a, b., b., c.\}, \{a \leftarrow \text{not } a, b., b., d.\}\}$
            \item $\mathcal{I}_{\text{MSI}}(P) = 2$
            \item $\mathcal{I}_{\text{MSI}}^\text{C}(P) = \frac{2}{3}$
            \item $\mathcal{I}_{\text{p}}(P) = 4$
        \end{itemize}
    \end{exampleblock}
\end{frame}
\section{Rationality Postulates}

\begin{frame}{Rationality Postulates}
    \begin{block}{Purpose}
        \begin{itemize}
            \item An inconsistency measure should indicate the degree of inconsistency in a knowledge base.
            \item Not just any function can be used; we need requirements for usefulness.
            \item These requirements are called \darkhighlight{rationality postulates}.
        \end{itemize}
    \end{block}
\end{frame}

\subsection{Basic Postulates}

\begin{frame}{Basic Postulates}
    \begin{block}{Consistency}
        For any knowledge base \(\mathcal{K}\):
        \[
            \mathcal{I}(\mathcal{K}) = 0 \text{ if and only if } \mathcal{K} \text{ is consistent}
        \]
    \end{block}
    \begin{alertblock}{Monotonicity}
        For knowledge bases \(\mathcal{K}\) and \(\mathcal{K}'\):
        \[
            \mathcal{I}(\mathcal{K}) \leq \mathcal{I}(\mathcal{K} \cup \mathcal{K}')
        \]
    \end{alertblock}
\end{frame}

\begin{frame}{Monotonicity Postulate}
    \begin{block}{Classical Monotonicity}
        \[
            \mathcal{I}(\mathcal{K}) \leq \mathcal{I}(\mathcal{K}')
        \]
        \begin{itemize}
            \item Adding information cannot reduce inconsistency.
            \item More information likely leads to more conflicts.
        \end{itemize}
    \end{block}
    \begin{alertblock}{Issue in Non-Monotonic Logics}
        \begin{itemize}
            \item New information may \emph{resolve} inconsistencies.
            \item Thus, \(\mathcal{I}(\mathcal{K}') < \mathcal{I}(\mathcal{K})\) is possible and expected.
        \end{itemize}
    \end{alertblock}
\end{frame}

\begin{frame}{Example of Monotonicity Issue}
    \begin{exampleblock}{Example}
        Consider the logic program:
        \[
            P = \{a \lor b.,\ a \leftarrow b.,\ c \leftarrow \text{not }b.,\ \neg c \leftarrow \text{not }b.\}
        \]
        \begin{itemize}
            \item \(H = \{c \leftarrow \text{not }b.,\ \neg c \leftarrow \text{not }b.,\ a \leftarrow b.\} \in SI_{\min}(P)\)
            \item Adding \(P' = \{b.,\ d.,\ \neg d.\}\) resolves conflicts in \(P\).
            \item Now \(SI_{\min}(P \cup P') = \{\{d.,\ \neg d.\}\}\)
        \end{itemize}
    \end{exampleblock}
    \begin{alertblock}{Conclusion}
        \begin{itemize}
            \item Comparison of \(\mathcal{I}(P)\) and \(\mathcal{I}(P \cup P')\) becomes unreasonable.
        \end{itemize}
    \end{alertblock}
\end{frame}

\begin{frame}{Free Formula Independence}
    Let \(\mathcal{K}\) and \(\mathcal{K}'\) be knowledge bases. \(\mathcal{K}'\) \highlight{preserves conflicts} of \(\mathcal{K}\) if:
    \[
        \forall \mathcal{H} \in SI(\mathcal{K}):\ \mathcal{H} \in SI(\mathcal{K} \cup \mathcal{K}')
    \]
    \begin{block}{Strong Monotonicity}
        If \(\mathcal{K}'\) preserves conflicts of \(\mathcal{K}\):
        \[
            \mathcal{I}(\mathcal{K}) \leq \mathcal{I}(\mathcal{K} \cup \mathcal{K}')
        \]
    \end{block}
\end{frame}

\begin{frame}{Basic Postulates}
    Let \(\mathcal{K}\) be a monotonic knowledge base. A formula \(\alpha \in \mathcal{K}\) is \highlight{free} if:
    \[
        \alpha \in \mathcal{K} \setminus \bigcup\limits_{\mathcal{H} \in I_{\min}(\mathcal{K})} \mathcal{H}
    \]
    Let \(Free(\mathcal{K})\) be the set of all free formulas of \(\mathcal{K}\).
\end{frame}

\begin{frame}{Generalization to Non-Monotonic Logics}
    A formula \(\alpha \in \mathcal{K}\) is free with respect to strong inconsistency or \highlight{SI-free} if:
    \[
        \alpha \in \mathcal{K} \backslash \bigcup\limits_{\mathcal{H} \in SI_{\min}(\mathcal{K})} \mathcal{H} = \bigcap\limits_{\mathcal{H} \in C_{\max}(\mathcal{K})} \mathcal{H}
    \]
    Let \(Free_{\text{SI}}(\mathcal{K})\) be the set of all SI-free formulas of \(\mathcal{K}\).
    \begin{block}{SI-Free}
        If \(\alpha \in Free_{\text{SI}}(\mathcal{K})\):
        \[
            \mathcal{I}(\mathcal{K}) \leq \mathcal{I}(\mathcal{K} \backslash \{\alpha\})
        \]
    \end{block}
\end{frame}

\begin{frame}{Issue with SI-Free Postulate}
    \begin{alertblock}{Issue with SI-Free Postulate}
        \begin{itemize}
            \item Removing SI-free formulas can affect the structure of \(SI_{\min}(\mathcal{K})\).
            \item May introduce new conflicts or alter existing ones.
        \end{itemize}
    \end{alertblock}
    \begin{exampleblock}{Example}
        Consider the logic program:
        \[
            P = \{a \leftarrow \text{not } a,\ b.,\ a \leftarrow \text{not } c.,\ d \leftarrow \text{not } d.,\ c.,\ d.\}
        \]
        \begin{itemize}
            \item \(\alpha = d.\) and \(\beta = a \leftarrow \text{not } c.\) are SI-free in \(P\).
            \item Removing \(\alpha\) or \(\beta\) changes \(SI_{\min}(P)\).
        \end{itemize}
    \end{exampleblock}
\end{frame}

\begin{frame}{Alternative to SI-Free}
    A formula \(\alpha\) is \highlight{neutral} if:
    \[
        \forall \mathcal{H} \subseteq \mathcal{K}:\ \mathcal{H} \in C(\mathcal{K}) \Leftrightarrow \mathcal{H} \cup \{\alpha\} \in C(\mathcal{K})
    \]
    Let \(Ntr(\mathcal{K})\) be the set of all neutral formulas of \(\mathcal{K}\).
    \begin{block}{Independence}
        If \(\alpha \in Ntr(\mathcal{K})\):
        \[
            \mathcal{I}(\mathcal{K}) = \mathcal{I}(\mathcal{K} \backslash \{\alpha\})
        \]
    \end{block}
\end{frame}

\begin{frame}{Basic Posulates}
    \begin{alertblock}{Dominance}
        \begin{itemize}
            \item Suggests that formulas carrying more information contribute more to inconsistency.
            \item Highly contested, even in propositional settings.
        \end{itemize}
    \end{alertblock}
    \begin{itemize}
        \item Generally disregarded in non-monotonic logics as more information can resolve conflicts.
    \end{itemize}
\end{frame}

\subsection{Extended Postulates}

\begin{frame}{Extended Postulates}
    \begin{alertblock}{Issue with Syntax}
        \begin{itemize}
            \item Syntax can affect inconsistency measures.
            \item Example: \(\{a \land b\}\) vs. \(\{a,\ b\}\).
        \end{itemize}
    \end{alertblock}
    Adjunction Invariance:
    \[
        \mathcal{I}(\mathcal{K} \cup \{a \land b\}) = \mathcal{I}(\mathcal{K} \cup \{a,\ b\})
    \]
\end{frame}

\begin{frame}{Strong Equivalence}
    Knowledge bases \(\mathcal{K}\) and \(\mathcal{K}'\) are \highlight{strongly equivalent} if:
    \[
        \forall \mathcal{G}:\ \text{ACC}(\mathcal{K} \cup \mathcal{G}) = \text{ACC}(\mathcal{K}' \cup \mathcal{G})
    \]
    \begin{block}{Strong Equivalence}
        If \(\mathcal{K} \equiv_S \mathcal{K}'\):
        \[
            \mathcal{I}(\mathcal{K}) = \mathcal{I}(\mathcal{K}')
        \]
    \end{block}
\end{frame}

\begin{frame}{FW-Strong Equivalence}
    \(\mathcal{K}\) and \(\mathcal{K}'\) are \highlight{formula-wise strongly equivalent} if:
    \[
        \exists\ \rho : \mathcal{K} \rightarrow \mathcal{K}'\ \text{bijective},\ \text{such that}\ \{\alpha\} \equiv_S \{\rho(\alpha)\}\ \forall \alpha \in \mathcal{K}
    \]
    \begin{block}{FW-Strong Equivalence}
        If \(\mathcal{K} \equiv_{\alpha} \mathcal{K}'\):
        \[
            \mathcal{I}(\mathcal{K}) = \mathcal{I}(\mathcal{K}')
        \]
    \end{block}
\end{frame}

\begin{frame}{Strong Equivalence Replacement}
    \begin{block}{Strong Equivalence Replacement}
        If \(\{\alpha\} \equiv_S \{\alpha'\}\) and \(\alpha,\ \alpha' \notin \mathcal{K}\):
        \[
            \mathcal{I}(\mathcal{K} \cup \{\alpha\}) = \mathcal{I}(\mathcal{K} \cup \{\alpha'\})
        \]
    \end{block}
    \begin{itemize}
        \item Inconsistency measure should be insensitive to replacement by strongly equivalent formulas.s
    \end{itemize}
\end{frame}

\begin{frame}{Separability}
    \begin{block}{Seperability}
        If:
        \begin{align*}
            SI_{\min}(\mathcal{K} \cup \mathcal{K}')            & = SI_{\min}(\mathcal{K}) \cup SI_{\min}(\mathcal{K}') \\
            SI_{\min}(\mathcal{K}) \cap SI_{\min}(\mathcal{K}') & = \emptyset
        \end{align*}
        Then:
        \[
            \mathcal{I}(\mathcal{K} \cup \mathcal{K}') = \mathcal{I}(\mathcal{K}) + \mathcal{I}(\mathcal{K}')
        \]
    \end{block}
    \begin{itemize}
        \item Inconsistency contributions from \(\mathcal{K}\) and \(\mathcal{K}'\) are independent.
        \item Total inconsistency is the sum of individual inconsistencies.
    \end{itemize}
\end{frame}

\begin{frame}{Strong Super-Additivity}
    \begin{block}{Strong Super-Additivity}
        If \(\mathcal{K}\) and \(\mathcal{K}'\) \darkhighlight{preserve each other's conflicts} and \(\mathcal{K} \cap \mathcal{K}' = \emptyset\):
        \[
            \mathcal{I}(\mathcal{K}) + \mathcal{I}(\mathcal{K}') \leq \mathcal{I}(\mathcal{K} \cup \mathcal{K}')
        \]
    \end{block}
    \begin{itemize}
        \item Inconsistency can increase when combining knowledge bases.
        \item Captures the potential interaction of conflicts.
    \end{itemize}
\end{frame}

\subsection{Compliance of Measures}

\begin{frame}{Compliance of Measures}
    \centering
    \begin{tabular}{lccc}
        \toprule
                                       & \(\mathcal{I}_{\text{MSI}}\) & \(\mathcal{I}_{\text{MSI}^\text{C}}\) & \(\mathcal{I}_{\text{p}}\) \\
        \midrule
        Consistency                    & \ding{51}                    & \ding{51}                             & \ding{51}                  \\
        Strong monotonicity            & \ding{51}                    & \ding{51}                             & \ding{51}                  \\
        SI-Free                        & \ding{55}                    & \ding{55}                             & \ding{55}                  \\
        Independence                   & \ding{51}                    & \ding{51}                             & \ding{51}                  \\
        Strong Equivalence             & \ding{55}                    & \ding{55}                             & \ding{55}                  \\
        FW-Strong Equivalence          & \ding{51}                    & \ding{51}                             & \ding{51}                  \\
        Strong Equivalence Replacement & \ding{51}                    & \ding{51}                             & \ding{51}                  \\
        Separability                   & \ding{51}                    & \ding{51}                             & \ding{55}                  \\
        Strong Super-Additivity        & \ding{51}                    & \ding{51}                             & \ding{51}                  \\
        \bottomrule
    \end{tabular}
\end{frame}

\begin{frame}{SI-Free Postulate}
    SI-free is not satisfied by any of the measures.
    \begin{exampleblock}{Example}
        Consider the logic program \(P = \{a \leftarrow \text{not } a, b., a \leftarrow \text{not }c, \text{not }d., b., c., d.\}\), which has:
        \[
            SI_{\min}(P) = \{\{a \leftarrow \text{not }a, b., b., c.\}, \{a \leftarrow \text{not }a, b., b., d.\}\}
        \]
        and \(\alpha = \{a \leftarrow \text{not }c, \text{not }d.\} \in Free_{\text{SI}}(P)\).

        The measures evaluate to:
        \[
            \mathcal{I}_{\text{MSI}}(P) = 2,\quad \mathcal{I}_{\text{MSI}^\text{C}}(P) = \frac{2}{3},\quad \mathcal{I}_{\text{p}}(P) = 4.
        \]
        But if \(\alpha\) is removed, they evaluate to:
        \[
            \mathcal{I}_{\text{MSI}}(P \backslash \{\alpha\}) = 1,\quad \mathcal{I}_{\text{MSI}^\text{C}}(P \backslash \{\alpha\}) = \frac{1}{2},\quad \mathcal{I}_{\text{p}}(P \backslash \{\alpha\}) = 2.
        \]
    \end{exampleblock}
\end{frame}

\section{Summary and Conclusion}

\begin{frame}{Summary}
    \begin{itemize}
        \item Addressed measuring inconsistencies in non-monotonic knowledge bases.
        \item Introduced strong inconsistency for non-monotonic logics.
        \item Applied strong inconsistency to extend inconsistency measures.
        \item Discussed rationality postulates for non-monotonic logics.
    \end{itemize}
\end{frame}

\begin{frame}{Conclusion}
    \begin{itemize}
        \item Provided an overview of inconsistencies in non-monotonic logics.
        \item Future work: Improve measures and compliance with rationality postulates.
        \item Applications: Repairing knowledge bases by adding formulas.
    \end{itemize}
\end{frame}
